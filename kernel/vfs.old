const std = @import("std");
const platform = @import("platform.zig");

const max_name_len = 256;

const Device = struct {};
const Cookie = [*]u8;

pub const Error = error{
    NotSupported,
    NoDevice,
    NoNodeFound,
    NodeFound,
    OutOfBounds,
};

pub const FileMode = packed struct {
    const RWX = packed struct {
        execute: bool = false,
        write: bool = false,
        read: bool = false,
    };

    everyone: RWX,
    group: RWX,
    user: RWX,
    _padding: u7 = 0,

    pub fn init(mode: u16) FileMode {
        var ret: FileMode = undefined;
        @ptrCast([*]align(@alignOf(FileMode)) u16, &ret) = mode;
        return ret;
    }

    pub fn toInt(self: FileMode) u16 {
        if (@sizeOf(FileMode) != @sizeOf(u16)) @compileError("Whoops!");
        return @ptrCast([*]align(@alignOf(FileMode)) const u16, &self)[0];
    }

    pub fn toString(self: FileMode, out: []u8) ![]const u8 {
        return try std.fmt.bufPrint(out, "{o}", .{self.toInt()});
    }

    pub const can_rwx = FileMode.RWX{ .read = true, .write = true, .execute = true };
    pub const can_rw = FileMode.RWX{ .read = true, .write = true };
    pub const world_writable = FileMode{ .user = FileMode.can_rw, .group = FileMode.can_rw, .everyone = FileMode.can_rw };
    pub const world_exec_writable = FileMode{ .user = FileMode.can_rwx, .group = FileMode.can_rwx, .everyone = FileMode.can_rwx };
};

pub const FileType = enum {
    File, Directory, BlockDevice, CharacterDevice, SymLink, Socket, Fifo, Null
};

pub const OpenFlags = struct {
    read: bool = true,
    write: bool = false,
};

pub const NodeOps = struct {
    create: ?fn(self: *Node, name: []const u8, mode: FileMode, type: FileType) anyerror!*Node = null,
    open: ?fn (self: *Node, open_flags: OpenFlags) anyerror!void = null,
    read: ?fn (self: *Node, offset: u64, buffer: []u8) anyerror!usize = null,
    write: ?fn (self: *Node, offset: u64, buffer: []const u8) anyerror!usize = null,
    findDir: ?fn (self: *Node, name: []const u8) anyerror!*Node = null,
    readDir: ?fn (self: *Node, offset: u64, buffer: []*Node) anyerror!usize = null,
    close: ?fn(self: *Node) anyerror!void = null,
};

pub const Node = struct {
    name: []const u8 = "null",
    name_buf: [256]u8 = undefined,
    device: ?*Device = null,
    cookie: ?Cookie = null,
    file_system: ?*FileSystem = null,
    allocator: ?*std.mem.Allocator = null,

    mode: FileMode = FileMode.world_writable,
    type: FileType = .Null,
    uid: u32 = 0,
    gid: u32 = 0,

    inode: u64 = 0,
    size: u64 = 0,

    access_time: i64 = 0,
    mod_time: i64 = 0,
    create_time: i64 = 0,

    ops: NodeOps = NodeOps{},

    pub fn getCookie(self: *Node, comptime T: type) *T {
        const algn = @alignOf(*T);
        return @ptrCast(*T, @alignCast(algn, self.cookie.?));
    }

    pub fn create(self: *Node, name: []const u8, mode: FileMode, typ: FileType) anyerror!*Node {
        if (self.ops.create == null) return Error.NotSupported;
        return self.ops.create.?(self, name, mode, typ);
    }

    pub fn open(self: *Node, open_flags: OpenFlags) anyerror!void {
        if (self.type == .Null) return;
        if (self.ops.open == null) return Error.NotSupported;
        return self.ops.open.?(self, open_flags);
    }

    pub fn read(self: *Node, offset: u64, buffer: []u8) anyerror!usize {
        if (self.type == .Null) return @as(usize, 0);
        if (self.ops.read == null) return Error.NotSupported;
        return self.ops.read.?(self, offset, buffer);
    }

    pub fn write(self: *Node, offset: u64, buffer: []const u8) anyerror!usize {
        if (self.type == .Null) return @as(usize, 0);
        if (self.ops.write == null) return Error.NotSupported;
        return self.ops.write.?(self, offset, buffer);
    }

    pub fn findDir(self: *Node, name: []const u8) anyerror!*Node {
        if (std.mem.eql(u8, name, ".")) return self;
        if (self.ops.findDir == null) return Error.NotSupported;
        return self.ops.findDir.?(self, name);
    }

    pub fn readDir(self: *Node, offset: u64, buffer: []*Node) anyerror!usize {
        if (self.ops.readDir == null) return Error.NotSupported;
        return self.ops.readDir.?(self, offset, buffer);
    }

    pub fn close(self: *Node) anyerror!void {
        if (self.ops.close == null) return;
        return self.ops.close.?(self);
    }
};

pub const FileSystemOps = struct {
    init: fn (fs: *FileSystem, allocator: *std.mem.Allocator, dev: ?*Device, args: ?[]const u8) anyerror!*Node,
};

pub const FileSystem = struct {
    name: []const u8,
    cookie: ?Cookie = null,
    ops: FileSystemOps,
    allocator: ?*std.mem.Allocator = null,

    pub fn getCookie(self: *FileSystem, comptime T: type) *T {
        const algn = @alignOf(*T);
        return @ptrCast(*T, @alignCast(algn, self.cookie.?));
    }

    pub fn init(self: *const FileSystem, allocator: *std.mem.Allocator, dev: ?*Device, args: ?[]const u8) anyerror!*Node {
        var newInstance = try allocator.create(FileSystem);
        errdefer { allocator.destroy(newInstance); }
        newInstance.name = self.name;
        newInstance.ops = self.ops;
        newInstance.allocator = allocator;
        return try newInstance.ops.init(newInstance, allocator, dev, args);
    }
};

pub var null_node = &Node{};

// TMPFS

const TmpFsNodeOps = NodeOps{
    .create = create,
    .open = open,
    .read = read,
    .write = write,
    .findDir = findDir,
    .close = close,
};

const TmpFsNodeCookie = struct {
    data: ?[]u8 = null,
    children: ?[]?*Node = null,
    ref_count: u64 = 0,
};

const TmpFsCookie = struct {
    file_memory: []u8,
    file_fba: std.heap.FixedBufferAllocator,
    file_allocator: *std.mem.Allocator,
    root_node: *Node,
    inode_n: u64,
};

pub const TmpFs = FileSystem{
    .name = "tmpfs",
    .ops = .{
        .init = init,
    },
};

fn init(self: *FileSystem, sys_allocator: *std.mem.Allocator, unused: ?*Device, args: ?[]const u8) anyerror!*Node {
    var cookie = try sys_allocator.create(TmpFsCookie);
    errdefer { sys_allocator.destroy(cookie); }
    cookie.file_memory = try sys_allocator.alloc(u8, 4 * 1024 * 1024); // for now, 4 MiB (TODO)
    errdefer { sys_allocator.free(cookie.file_memory); }
    cookie.file_fba = std.heap.FixedBufferAllocator.init(cookie.file_memory);
    cookie.file_allocator = &cookie.file_fba.allocator;
    cookie.inode_n = 1;

    var root_node = try cookie.file_allocator.create(Node);
    errdefer { sys_allocator.destroy(root_node); }
    root_node.file_system = self; 
    root_node.ops = TmpFsNodeOps;

    root_node.name = "/";

    root_node.mode = FileMode.world_exec_writable;
    root_node.type = .Directory;
    root_node.inode = cookie.inode_n;
    cookie.inode_n += 1;

    var now = platform.getTimeNano();
    root_node.access_time = now; root_node.mod_time = now; root_node.create_time = now;

    var root_node_cookie = try cookie.file_allocator.create(TmpFsNodeCookie);
    errdefer { sys_allocator.destroy(root_node_cookie); }
    root_node_cookie.children = try cookie.file_allocator.alloc(?*Node, 0);

    root_node.cookie = @ptrCast(Cookie, root_node_cookie);
    cookie.root_node = root_node;
    self.cookie = @ptrCast(Cookie, cookie);
    return root_node;
}

fn create(self: *Node, name: []const u8, mode: FileMode, typ: FileType) anyerror!*Node {
    if (typ != .File and typ != .Directory and typ != .Null) return Error.NotSupported;
    var cookie = self.getCookie(TmpFsNodeCookie);
    var fs_cookie = self.file_system.?.getCookie(TmpFsCookie);
    if (findDir(self, name)) { return Error.NodeFound; } else |err| {}

    var new_node = try fs_cookie.file_allocator.create(Node);
    errdefer { fs_cookie.file_allocator.destroy(new_node); }
    new_node.file_system = self.file_system;
    new_node.ops = TmpFsNodeOps;

    std.mem.copy(u8, new_node.name_buf[0..], name);
    new_node.name = new_node.name_buf[0..name.len];

    new_node.mode = FileMode.world_exec_writable;
    new_node.type = typ;
    new_node.inode = fs_cookie.inode_n;

    var now = platform.getTimeNano();
    new_node.access_time = now; new_node.mod_time = now; new_node.create_time = now;

    var new_node_cookie = try fs_cookie.file_allocator.create(TmpFsNodeCookie);
    errdefer { fs_cookie.file_allocator.destroy(new_node_cookie); }

    switch(typ) {
        .File => {
            new_node_cookie.data = try fs_cookie.file_allocator.alloc(u8, 0);
            errdefer { fs_cookie.file_allocator.free(new_node_cookie.data.?); }
        },
        .Directory => {
            new_node_cookie.children = try fs_cookie.file_allocator.alloc(?*Node, 0);
            errdefer { fs_cookie.file_allocator_free(new_node_cookie.children.?); }
        },
        .Null => {},
        else => unreachable,
    }

    new_node.cookie = @ptrCast(Cookie, new_node_cookie);
    cookie.children = try fs_cookie.file_allocator.alloc(?*Node, cookie.children.?.len + 1); // TODO: prevent infinite growth
    cookie.children.?[cookie.children.?.len - 1] = new_node;
    fs_cookie.inode_n += 1;
    return new_node;
}

fn open(self: *Node, open_flags: OpenFlags) anyerror!void {
    self.getCookie(TmpFsNodeCookie).ref_count += 1;
}

fn write(self: *Node, offset: u64, buffer: []const u8) anyerror!usize {
    if (self.type != .File) return Error.NotSupported;
    var cookie = self.getCookie(TmpFsNodeCookie);
    var fs_cookie = self.file_system.?.getCookie(TmpFsCookie);

    if (offset > cookie.data.?.len) return Error.OutOfBounds;

    var maybeNewSize = @as(usize, offset) + buffer.len;
    if (maybeNewSize > cookie.data.?.len)
        cookie.data = try fs_cookie.file_allocator.realloc(cookie.data.?, maybeNewSize); 
    
    // TODO: update mtime, atime
    var now = platform.getTimeNano();
    self.mod_time = now; self.access_time = now;
    std.mem.copy(u8, cookie.data.?[@intCast(usize, offset)..], buffer);
    self.size = cookie.data.?.len;
    return buffer.len;
}

fn read(self: *Node, offset: u64, buffer: []u8) anyerror!usize {
    if (self.type != .File) return Error.NotSupported;
    var cookie = self.getCookie(TmpFsNodeCookie);
    var fs_cookie = self.file_system.?.getCookie(TmpFsCookie);

    var trueRangeEnd = @intCast(usize, offset) + buffer.len;
    if (trueRangeEnd > cookie.data.?.len) trueRangeEnd = cookie.data.?.len;

    var now = platform.getTimeNano();
    self.access_time = now;
    std.mem.copy(u8, buffer, cookie.data.?[@intCast(usize, offset)..trueRangeEnd]);
    return trueRangeEnd - @intCast(usize, offset);
}

fn findDir(self: *Node, name: []const u8) anyerror!*Node {
    if (self.type != .Directory) return Error.NotSupported;
    var cookie = self.getCookie(TmpFsNodeCookie);
    for (cookie.children.?) |node| {
        if (node == null) continue;
        if (std.mem.eql(u8, name, node.?.name)) {
            return node.?;
        }
    }
    return Error.NoNodeFound;
}

fn readDir(self: *Node, offset: u64, buffer: []*Node) anyerror!usize {
    if (self.type != .Directory) return Error.NotSupported;
    var cookie = self.getCookie(TmpFsNodeCookie);

    if (offset >= cookie.children.?.len) return 0;

    var i = 0;
    for (cookie.children.?[@intCast(usize, offset)..]) |node| {
        if (i >= buffer.len) break;
        if (node != null) {
            buffer[i] = node.?;
            i += 1;
        }
    }
    return i;
}

fn close(self: *Node) anyerror!void {
    self.getCookie(TmpFsNodeCookie).ref_count -= 1;
}
